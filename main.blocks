<xml xmlns="https://developers.google.com/blockly/xml"><variables></variables><block type="pxt-on-start" id="c=gCXAQN,~y**qEg;#(?" x="20" y="20"><statement name="HANDLER"><block type="typescript_statement" id="MtC{chK)%e*L~XKf#M^z"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace Module_World_Color {" line1="" line2="    const COLOR_ADD = 0X53;" line3="    const COLOR_REG = 0x00;" line4="    const COLOR_R = 0X10;" line5="    const COLOR_G = 0X0D;" line6="    const COLOR_B = 0x13;" line7="" line8="    let initialized = false;" line9="    let val_red = 0;" line10="    let val_green = 0;" line11="    let val_blue = 0;" line12="" line13="    export enum enGetRGB {" line14="        //% blockId=&quot;GetValueR&quot; block=&quot;GetValueR&quot;" line15="        GetValueR = 0," line16="        //% blockId=&quot;GetValueG&quot; block=&quot;GetValueG&quot;" line17="        GetValueG = 1," line18="        //% blockId=&quot;GetValueB&quot; block=&quot;GetValueB&quot;" line19="        GetValueB = 2" line20="    }" line21="" line22="    function i2cWriteData(addr: number, reg: number, value: number) {" line23="        let buf = pins.createBuffer(2);" line24="        buf[0] = reg;" line25="        buf[1] = value;" line26="        pins.i2cWriteBuffer(addr, buf);" line27="    }" line28="" line29="    function setRegConfig(): void {" line30="        i2cWriteData(COLOR_ADD, COLOR_REG, 0X06);" line31="        i2cWriteData(COLOR_ADD, 0X04, 0X41);" line32="        i2cWriteData(COLOR_ADD, 0x05, 0x01);" line33="    }" line34="" line35="    function initColorI2C(): void {" line36="        setRegConfig();" line37="        initialized = true;" line38="    }" line39="" line40="    function GetRGB(): void {" line41="        let buff_R = pins.createBuffer(2);" line42="        let buff_G = pins.createBuffer(2);" line43="        let buff_B = pins.createBuffer(2);" line44="" line45="        pins.i2cWriteNumber(COLOR_ADD, COLOR_R, NumberFormat.UInt8BE);" line46="        buff_R = pins.i2cReadBuffer(COLOR_ADD, 2);" line47="" line48="        pins.i2cWriteNumber(COLOR_ADD, COLOR_G, NumberFormat.UInt8BE);" line49="        buff_G = pins.i2cReadBuffer(COLOR_ADD, 2);" line50="" line51="        pins.i2cWriteNumber(COLOR_ADD, COLOR_B, NumberFormat.UInt8BE);" line52="        buff_B = pins.i2cReadBuffer(COLOR_ADD, 2);" line53="" line54="        let Red = (buff_R[1] &amp; 0xff) &lt;&lt; 8 | (buff_R[0] &amp; 0xff);" line55="        let Green = (buff_G[1] &amp; 0xff) &lt;&lt; 8 | (buff_G[0] &amp; 0xff);" line56="        let Blue = (buff_B[1] &amp; 0xff) &lt;&lt; 8 | (buff_B[0] &amp; 0xff);" line57="" line58="        if (Red &gt; 4500) Red = 2300;" line59="        if (Green &gt; 7600) Green = 4600;" line60="        if (Blue &gt; 4600) Blue = 2700;" line61="" line62="        val_red = Math.map(Red, 0, 2300, 0, 255);" line63="        val_green = Math.map(Green, 0, 4600, 0, 255);" line64="        val_blue = Math.map(Blue, 0, 2700, 0, 255);" line65="" line66="        //化成整数" line67="        val_red = Math.floor(val_red)" line68="        val_green = Math.floor(val_green)" line69="        val_blue = Math.floor(val_blue)" line70="" line71="        if (val_red &gt; 255) val_red = 255;" line72="        if (val_green &gt; 255) val_green = 255;" line73="        if (val_blue &gt; 255) val_blue = 255;" line74="" line75="        if (val_red == val_green &amp;&amp; val_red == val_blue) {" line76="            val_red = 255;" line77="            val_green = 255;" line78="            val_blue == 255;" line79="        }//3值相等，当成白色处理" line80="        else if (val_red &gt; val_green &amp;&amp; val_red &gt; val_blue) {" line81="            if (val_red &gt; 55) //当R值大于此值，说明检测红色" line82="            {" line83="                val_red = 255;" line84="                val_green /= 2;" line85="                val_blue /= 2;" line86="            }//否则值不处理" line87="        }" line88="        else if (val_green &gt; val_red &amp;&amp; val_green &gt; val_blue) {" line89="            val_green = 255;" line90="            val_red /= 2;" line91="            val_blue /= 2;" line92="        }" line93="        else if (val_blue &gt; val_red &amp;&amp; val_blue &gt; val_green) {" line94="            val_blue = 255;" line95="            val_red /= 2;" line96="            val_green /= 2;" line97="        }" line98="    }" line99="" line100="    //% blockId=ModuleWorld_Sensor_GetRGBValue block=&quot;GetRGBValue|value %value&quot;" line101="    //% blockGap=20" line102="    //% weight=98" line103="    //% color=&quot;#0000cd&quot;" line104="    //% name.fieldEditor=&quot;gridpicker&quot; name.fieldOptions.columns=5" line105="    export function GetRGBValue(value: enGetRGB): number {" line106="        if (!initialized) {" line107="            initColorI2C();" line108="        }" line109="        GetRGB();" line110="        switch (value) {" line111="            case enGetRGB.GetValueR:" line112="                return val_red;" line113="            case enGetRGB.GetValueG:" line114="                return val_green;" line115="            case enGetRGB.GetValueB:" line116="                return val_blue;" line117="            default:" line118="                break;" line119="        }" line120="        return 0;" line121="    }" line122="" line123="}" numlines="124"></mutation></block></statement></block></xml>